---
description: Backend development standards, best practices, and conventions for the Investment Tracker .NET application including Domain-Driven Design, Vertical Slice Architecture (VSA), and C# 14 practices.
globs: ["src/**/*.cs", "tests/**/*.cs", "**/*.csproj", "**/appsettings.json", "Directory.Packages.props", "Directory.Build.props"]
alwaysApply: true
---

# Backend Project Standards and Best Practices

## Table of Contents

- [Overview](#overview)
- [Technology Stack](#technology-stack)
- [Architecture Overview](#architecture-overview)
  - [Clean Architecture Layers](#clean-architecture-layers)
  - [Project Structure](#project-structure)
- [Domain-Driven Design Principles](#domain-driven-design-principles)
  - [Entities](#entities)
  - [Value Objects](#value-objects)
  - [Repositories](#repositories)
- [Coding Standards](#coding-standards)
  - [Naming Conventions](#naming-conventions)
  - [C# Guidelines](#c-guidelines)
  - [Async/Await](#asyncawait)
- [Database Patterns](#database-patterns)
  - [Entity Framework Core](#entity-framework-core)
  - [Migrations](#migrations)
- [Testing Standards](#testing-standards)
  - [Unit Testing](#unit-testing)
  - [Integration Testing](#integration-testing)
- [Development Workflow](#development-workflow)

---

## Overview

This document serves as the foundation for maintaining code quality and consistency across the Investment Tracker backend application.

## Technology Stack

- **Framework**: .NET 10 (LTS)
- **Language**: C# 14
- **ORM**: Entity Framework Core 10
- **Database**: SQLite (Local), PostgreSQL (Production)
- **Testing**: Microsoft.Testing.Platform (MTP), xUnit v3, FluentAssertions, Moq
- **Orchestration**: .NET Aspire

## Architecture Overview

The project adopts a hybrid approach, using **Vertical Slice Architecture (VSA)** for Web APIs and **Clean Architecture** for complex, long-lived domain logic.

### Vertical Slice Architecture (VSA)
- **Preferred for Web APIs**: Group code by feature (e.g., `PlaceOrder` folder containing DTOs, Logic, and Endpoint).
- **Benefits**: Reduces file hopping, aligns with Minimal APIs, and improves developer velocity.
- **Sharing Strategy**:
    - **Entities**: ALWAYS SHARE. Core business truths belong in the Domain layer.
    - **DTOs**: AGGRESSIVELY DUPLICATE. Do not share DTOs between features to avoid tight coupling. "Duplication is cheaper than the wrong abstraction."
    - **Data Logic**: Use **Extension Methods** on `IQueryable` for complex queries instead of Repositories.
    - **Shared Biz Logic**: Use **Domain Services** for universal logic (e.g., Tax calculation).
- **The "Rule of Three" for Refactoring**:
    1. Write the code in Slice A (no sharing).
    2. Copy it to Slice B (accept duplication).
    3. Copy it to Slice C -> **STOP**. Only then extract to a shared component.

### Clean Architecture Layers

1.  **Domain (`src/InvestmentTracker.Domain`)**:
    -   Contains the core business logic, entities, value objects, and repository interfaces.
    -   **Dependencies**: None (Pure C#).
    -   *Rules*: No reference to external libraries or infrastructure concerns.

2.  **Infrastructure (`src/InvestmentTracker.Infra`)**:
    -   Implements interfaces defined in Domain (e.g., Repositories).
    -   Handles database access (EF Core context), file systems, and external API calls.
    -   **Dependencies**: Domain, EF Core, External SDKs.

3.  **UI/Presentation (`src/InvestmentTracker.UI`)**:
    -   The entry point of the application (Console App or Web API).
    -   Orchestrates application flow.
    -   **Dependencies**: Domain, Infrastructure.

### Project Structure

```text
src/
  InvestmentTracker.Domain/   # Entities, Interfaces, Domain Services
  InvestmentTracker.Infra/    # EF Core DbContext, Repositories Implementation
  InvestmentTracker.UI/       # Console Application / API Entry Point
tests/
  InvestmentTracker.Tests/    # Unit and Integration Tests
```

## Domain-Driven Design Principles

### Entities
-   Entities should have a private constructor for EF Core and a public constructor/factory method for creation.
-   Properties should generally be `private set` to enforce encapsulation, allowing modification only through methods.
-   Example: `Asset`, `Snapshot`.

### Value Objects
-   Immutable objects defined by their attributes rather than identity.
-   Use `record` types or classes with equality overrides.

### Repositories
-   Define repository interfaces in the **Domain** layer (e.g., `IAssetRepository`).
-   Implement them in the **Infrastructure** layer.
-   Return Domain Entities, not Database Models (if using separate models, otherwise map carefully).

## Coding Standards

### Naming Conventions
-   **Classes/Interfaces**: PascalCase (`Asset`, `IPortfolioService`).
-   **Methods**: PascalCase (`CalculateFees`).
-   **Variables/Parameters**: camelCase (`assetId`, `totalValue`).
-   **Private Fields**: `_camelCase` (`_dbContext`).
-   **Constants**: PascalCase (`MaxRetryCount`).
-   **Interfaces**: Prefix with 'I' (`IRepository`).

### C# 14 Guidelines
-   **field Keyword**: Use the `field` keyword in property accessors to access compiler-synthesized backing fields for validation or notification logic.
-   **Extension Members**: Use extension properties and static members to attach UI or Infrastructure-specific logic to Domain Entities without modifying the core types.
-   **Implicit Conversions for Span<T>**: Default to `ReadOnlySpan<char>` for string-processing methods to achieve zero-allocation parsing.
-   Use **Implicit Usings** and **File-Scoped Namespaces** to reduce boilerplate.
-   Use `var` when the type is obvious from the right-hand side.
-   Prefer `is not null` over `!= null`.
-   Use `record` for DTOs and simple data structures.

### Async/Await
-   All I/O bound operations (Database, File, Network) must be `async`.
-   Use `await` and avoid `.Result` or `.Wait()` to prevent deadlocks.
-   Suffix async methods with `Async` (e.g., `GetAllAssetsAsync`).

## Database Patterns

### Entity Framework Core
-   Use `DbContext` for database interactions.
-   Configure entities using `IEntityTypeConfiguration<T>` in separate files, not `OnModelCreating` directly (keep Context clean).
-   Use **LINQ** for querying.

### Migrations
-   Use EF Core migrations to manage database schema changes.
-   Commands:
    -   `dotnet ef migrations add <MigrationName> --project src/InvestmentTracker.Infra --startup-project src/InvestmentTracker.UI`
    -   `dotnet ef database update --project src/InvestmentTracker.Infra --startup-project src/InvestmentTracker.UI`

## Testing Standards

### Unit Testing
-   Project: `InvestmentTracker.Tests`.
-   Runner: **Microsoft.Testing.Platform (MTP)** (Standalone executable execution).
-   Framework: **xUnit v3**.
-   Assertion Library: **FluentAssertions**.
-   Mocking: **Moq**.
-   Focus on testing **Domain Logic** and **Services**.
-   Test naming convention: `MethodName_StateUnderTesting_ExpectedBehavior`.

### Integration Testing
-   Test database interactions using an in-memory database or a test SQLite file.
-   Verify end-to-end flows.

## Development Workflow
1.  **Branching**: Create feature branches from `main`.
2.  **Implementation**:
    -   Define/Update Domain Entity.
    -   Create/Update Repository Interface.
    -   Implement Repository in Infra.
    -   Implement/Update Service/UI logic.
    -   Write/Run Tests.
3.  **Verification**: Ensure `dotnet test` passes before committing.
